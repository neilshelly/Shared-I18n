Create a NEW repo named `shared-i18n`.

Before you write any code, read and follow these documents that I will paste into Replit as separate inputs:

1. Shared Translation Architecture (authoritative requirements for this repo)
2. Web Suite System Architecture and Trust Boundaries (follow relevant boundaries, but do not add service behavior)
3. Engineering Baseline for Web Clients (apply relevant TypeScript and repo hygiene conventions where applicable to a package)
4. Repo Template and Environment Variable Matrix (confirm there are no env vars for this package and do not introduce any)

Do not proceed until you have read all four inputs.

Goal
Implement `shared-i18n` exactly per Shared Translation Architecture:

* Static locale catalogues under `src/locales/`:

  * `en.json` is canonical
  * `de-DE.json` must exist and must match the canonical key set exactly
* CI style checks (implemented locally as scripts and tests) for:

  * identical key sets across locales
  * placeholder consistency across locales
  * JSON validity
* Generated type contract derived automatically from `src/locales/en.json`:

  * `TranslationKey` union
  * `translationKeys` readonly array
* Manual union maintenance is prohibited.
* No runtime i18n logic beyond exporting static catalogues and generated types.
* No environment variables, no API calls, no auth, no service behavior.

Repository structure (must match the architecture doc)

shared-i18n/
package.json
src/
locales/
en.json
de-DE.json

Implementation requirements

1. Package setup (publishable TypeScript package)

* This is a package repo only.
* Use TypeScript build output in `dist/`.
* Ensure consumers can import:

  * locale catalogues
  * `TranslationKey`
  * `translationKeys`
* Configure `package.json` as a publishable package:

  * name: "shared-i18n"
  * version: "0.1.0"
  * private: false
  * type: "module"
  * main/module/types pointing to built outputs in dist
  * exports map supports:

    * root entry `.` to dist outputs (types plus js)
    * optionally `./locales/*` export so consumers can import JSON directly if needed
  * files includes `dist/` and `src/locales/`
  * sideEffects: false
  * publishConfig: access public
* Critical: Replit may block direct edits to package.json.

  * If you cannot edit package.json directly, overwrite it via shell using a heredoc, then re-run npm install.

Use minimal and conventional tooling:

* TypeScript
* A minimal test runner (vitest preferred)
* tsx for running scripts in TS

Add these scripts to package.json:

* gen: run generator
* validate: run validator
* build: run gen then tsc
* test: run gen then validate then unit tests
* prepublishOnly: run test then build

2. Locale files

Create `src/locales/en.json` and `src/locales/de-DE.json` as flat key:string maps.

Follow naming rules (dot notation, stable keys, approved namespaces).

Include a minimal starter set that demonstrates:

* `auth.signed_out`
* `common.loading`
* `common.cancel`
* `errors.generic.not_found`
* `errors.generic.request_error`
* `errors.generic.service_unavailable`
* `errors.validation.min_length` with placeholder `{{min}}`

Ensure both locales have identical keys and identical placeholder names per key.

3. Validation script (CI requirements)

Create `scripts/validate-locales.ts` that:

* Discovers all `src/locales/*.json`
* Parses JSON and fails on invalid JSON
* Treats `en.json` as canonical key set
* For every other locale:

  * Fail if there are missing keys or extra keys compared to canonical
  * For each key, validate the value is a string
  * Extract placeholders of the form `{{name}}` from each value and compare placeholder sets exactly against canonical for that key
  * Fail if placeholder names differ across locales for the same key
  * Fail if a value contains `{{` without a matching `}}`
* Also validate there are no nested objects anywhere in locale JSON (flat key:string map only)

Design the validator for testability:

* Export the core function and allow an optional base path so tests can run against fixtures without touching src/locales.

4. Generated type contract (no manual unions)

Create `scripts/generate-translation-keys.ts` that:

* Reads `src/locales/en.json`
* Generates `src/generated/translation-keys.ts` deterministically (sorted keys)
* The generated file must export:

  * `export type TranslationKey = 'a.b' | 'c.d' | ...`
  * `export const translationKeys = [...] as const satisfies readonly TranslationKey[]`
* Do not hand write the union.
* Ensure build and test always regenerate this file.
* Manual maintenance is prohibited. Always derive from canonical key set.

5. Public package entry

Create `src/index.ts` that exports:

* `TranslationKey` and `translationKeys` from `src/generated/translation-keys`
* Locale JSON exports for consumers:

  * `export { default as en } from './locales/en.json'`
  * `export { default as deDE } from './locales/de-DE.json'`

Enable JSON imports in tsconfig (resolveJsonModule) and ensure build emits usable JS and d.ts.

Do not add any translation functions, locale selection logic, interpolation helpers, or runtime behavior beyond exporting data and generated types.

6. Tests

Add unit tests that assert:

* validate passes for the starter locale files
* validate fails when:

  * a locale has an extra key
  * a locale is missing a key
  * a placeholder name differs for the same key

Implement tests by creating temporary fixtures under a temp directory and running the validator core function against that directory.

7. Documentation

Add README.md stating:

* en.json is canonical
* all locales must match keys and placeholders exactly
* TranslationKey and translationKeys are generated from en.json and must not be manually maintained
* consumers import types from shared-i18n and merge shared catalogue with app specific catalogues at runtime
* versioning rules: major for removal, rename, or placeholder structure changes; minor for additive keys; patch for packaging or docs only
* repo contains no runtime i18n logic beyond static catalogues and generated types

8. Final run and verification

Run `npm test` and `npm run build` and fix anything until both succeed.

Add a non-published smoke script `scripts/smoke.ts` (excluded from exports) that imports from the built entry and logs:

* Array.isArray(translationKeys) and translationKeys.length
* typeof en and typeof deDE
  It must not import or reference any translation function since none should exist.

After completion, report:

* which scripts you ran
* that `npm test` and `npm run build` succeed
* that `dist/` contains compiled outputs

Verification checklist (run after creation)

* npm test
* npm run build
* node -e "import { translationKeys } from './dist/index.js'; console.log(Array.isArray(translationKeys), translationKeys.length)"
* node -e "import { en, deDE } from './dist/index.js'; console.log(typeof en, typeof deDE)"
